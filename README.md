# primary_key_perf - A test rig for measuring the impact of primary key selection in SQL databases

Goal: To see how the choice of a primary keys affects disk I/O in different DB engines, especially comparing clustered and non-clustered indexes

## What is being measured?

Disk I/O - read and write volume in bytes

## How is it measured?

The database is run in a Docker container and Docker's Stats API is being periodically polled

## Testing scenario

The script creates a table with a configurable type of primary key and 

The following DB Engine tests were implemented:

SQLite - both clustered and non-clustered mode
MariaDB - InnoDB is inherently clustered
PostgreSQL - inherently non-clustered

## Results

The results and figures generated by these scripts were used in the following articles:

- [Choose the right primary key to save a large amount of disk I/O](https://www.toomanyafterthoughts.com/primary-key-random-sequential-performance/)

- [UUIDs Are Bad for Database Index Performance, enter UUID7!](https://www.toomanyafterthoughts.com/uuids-are-bad-for-database-index-performance-uuid7/)


## How to run the tests?

The entry point for testing is the `main.py` script. To set the combinations that are being tested, update the list in the `run_configs` variable. The other important config variables are `BATCH_SIZE` and `BATCH_COUNT`.

The DB instances and the test scripts are started in tandem by running `docke-rcompose up`.

## Plotting results

After the tests were run, the output .JSON files are saved into the `results` directory. 

The `plot.py` script is used to read the data and plot graphs. The resulting figures are also stored in the `figs` directory.
